/*
 * An example of using the GPars library for parallelism.
 *
 * This example uses the GPars Dataflow to ensure each service in a pipeline
 * is kept as busy as possible.
 */
import util.DataSourceIterator
import util.ServiceProvider
@Grab(group='org.codehaus.gpars', module='gpars', version='1.1.0')
import groovyx.gpars.*
import groovyx.gpars.dataflow.*

class Packet {
	Data data // The data being worked on.
	File dest // Where the result will be written.
	String key // The MASC index key of the original document.
}


include 'Servers'
include 'Common'

def datasource = Datasource {
	server servers.localhost
	name 'picard:masc.text_1.3.0'
}

String[] keys = datasource.list()

// These are the common services between the two providers we want to invoke.
def services = [ 'tokenizer', 'splitter', 'tagger', 'ner' ]

// Get the service clients.
def gate = new ServiceProvider(servers.vassar, 'gate', '1.3.1', services)
def stanford = new ServiceProvider(servers.vassar, 'stanford', '1.3.0', services)

// Create directories for the output.
File gateDest = createDir('/Users/suderman/Projects/LAPPS/output/gate')
File stanfordDest = createDir('/Users/suderman/Projects/LAPPS/output/stanford')

// Fetch a document from the datasource.
def get = { packet ->
	println "Getting data for key ${packet.key}"
	packet.data = datasource.get(packet.key)
	return packet
}

// Execute the service on the data in the packet.
def execute = { service, packet ->
	if (packet.data == null) {
		println "Packet data is NULL!"
		return packet
	}
	if (packet.data.discriminator == Types.ERROR) {
		println "Error encountered. Skipping ${service.endpoint}"
		println packet.data.payload
		return packet
	}
	println "Running ${service.endpoint} ${packet.key}"
	packet.data = service.execute(packet.data)
	return packet
}

// Saves data to the GATE destination directory.
int gateCount = 0
def gateSave = { packet ->
	if (packet.data.discriminator == Types.ERROR) {
		println "No saving ${packet.key}"
		println packet.data.payload
		return packet.key
	}
	File file = new File(gateDest, "${packet.key}.xml")
	file.text = packet.data.payload
	println "${++gateCount}. Wrote ${file.path}"
	return packet.key
}

// Saves data to the Stanford destination directory.
int stanfordCount = 0
def stanfordSave = { packet ->
	File file = new File(stanfordDest, "${packet.key}.json")
	file.text = packet.data.payload
	println "${++stanfordCount}. Wrote ${file.path}"
	return packet.key
}

GParsPool.withPool {
	
	def gateQ = new DataflowQueue()
	def stanfordQ = new DataflowQueue()
	
	def buildChannel = { queue, provider, save ->
		DataflowReadChannel channel = queue | 
			execute.curry(provider.tokenizer) |
			execute.curry(provider.splitter) |
			execute.curry(provider.tagger) |
			execute.curry(provider.ner) | save
		return channel
	}
	
	DataflowReadChannel gateChannel = buildChannel(gateQ, gate, gateSave)
	DataflowReadChannel stanfordChannel = buildChannel(stanfordQ, stanford, stanfordSave)
	//DataflowReadChannel gateChannel = gateQ | execute.curry(gate.tokenizer) |
	//	execute.curry(gate.splitter) | execute.curry(gate.tagger) | 
	//	execute.curry(gate.ner) | gateSave
		
	boolean waitForGate = false
	boolean waitForStanford = false
	def targets = []
	if (args.gate) {
		targets << gateQ
		waitForGate = true
	}
	else if (args.stanford) {
		targets << stanfordQ
		waitForStanford = true
	}
	else if (args.both) {
		targets << stanfordQ
		targets << gateQ
		waitForGate = true
		waitForStanford = true
	}
	else {
		println "Unknown provider ${args.provider}"
		return
	}

	// The getterChannel will send data to both Gate and Stanford workflows.
	def getterQ = new DataflowQueue()
	DataflowReadChannel getterChannel =  getterQ.chainWith(get).split(targets)
	
	String lastKey = null
	keys[0..9].each { key ->		
		Packet packet = new Packet()
		packet.key = key
		getterQ << packet
		lastKey = key
	} 
	println "The last key is ${lastKey}"
	
	if (waitForGate) {
		println "Waiting on the Gate work flow."	
		while (gateChannel.val !=  lastKey) { sleep 100 }
	}
	
	if (waitForStanford) {
		println "Waiting on the stanford work flow."
		while (stanfordChannel.val != lastKey) { sleep 100 }
	}
}
println "Done."

